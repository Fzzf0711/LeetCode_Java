# Java 基础知识学习与总结

## 1.1 Java 修饰符

### 1.1.1 访问控制符
    public: 公共的，可以被类、子类、或者其他类的任何其他类访问。
    使用对象: 类 接口 变量 方法

    protected: 受保护的，可以被类、子类、或者其他类的任何其他类访问。
    使用对象: 变量 方法 不能修饰类(外部类)

    private: 私有的，只能被当前类访问。
    使用对象: 变量 方法 不能修饰类(外部类)

    default: 默认的，可以被类、子类、或者其他类的任何其他类访问。
    使用对象: 类 接口 变量 方法

### 1.1.2 非访问控制符
    
    static: 静态的，可以被类、子类、或者其他类的任何其他类访问。

    静态变量: 关键字用来声明独立于对象的静态变量，静态变量的值是在类加载时确定的，而不是在实例化时确定的。静态变量只有一份拷贝，也被称为类变量，局部变量不能被声明为static变量。

    静态方法: 关键字用来声明独立于对象的静态方法，静态方法的调用不需要实例化对象，而是通过类名调用。

    final: 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。final修饰符通常和static修饰符一起使用来创建类常量。

    final关键字用来声明一个类或者方法不能被继承，可以被继承的类是父类，不可以被继承的类是子类。

    final 方法：父类的final方法可以被子类继承，但是不能被子类重写。
    声明final方法主要目的是否防止该方法的内容被篡改。

    abstract: 抽象的，可以被类、子类、或者其他类的任何其他类访问。

    抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。
    抽象类可以包含抽象方法和非抽象方法。

    抽象方法
    抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。
    抽象方法不能被声明成 final 和 static。
    任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。
    如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。
    抽象方法的声明以分号结尾，例如：public abstract sample();。

    synchronized 修饰符
    同步方法：同步方法是一种同步的方法，它的作用是防止多个线程同时访问同一个对象的同一个方法。

    transient 修饰符
    序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

    volatile 修饰符
    volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

## 1.2 Java 流(Stream)、文件(File)和IO
    Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。
    Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。
    一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。

## 1.3 Java 异常处理

### 1.3.1 Java异常类型
    检查性异常：用户错误或者问题引起的异常，无法在编译时被忽略。
    运行时异常：可被避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。
    错误：错误不是异常，而是脱离控制的问题，错误在代码中通常被忽略。

### 1.3.2 Java Exception 类的层次
    所有的异常类是从java.lang.Exception 类继承的子类。
    Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。

    Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。
    
    Error 用来指示运行时环境发生的错误。

    例如，JVM 内存溢出。一般地，程序不会从错误中恢复。

    异常类有两个主要的子类：IOException 类和 RuntimeException 类。

### 1.3.3 捕获异常
    使用try、catch 关键字可以捕获异常，try，catch 代码块放在异常可能发生的地方。
    try，catch代码块中的代码称为保护的代码。

    catch 语句包含要捕获异常类型的声明，当保护代码块中发生一个异常时，try后面的catch块就会被检查。如果发生的异常包含在catch块中，异常会被传递到catch块。

### 1.3.4 抽象类和接口
抽象类
特点:
1. 抽象类中可以构造方法
2. 抽象类中可以存在普通属性，方法，静态属性和方法。
3. 抽象类中可以存在抽象方法。
4. 如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。
5. 抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。
6. 抽象类不能被实例化，抽象类和抽象方法必须被abstract修饰

关键字使用注意：
抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。

接口
1. 在接口中只有方法的声明，没有方法体。
2. 在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final
3. 在接口中的方法，永远都被public来修饰。
4. 接口中没有构造方法，也不能实例化接口的对象。（所以接口不能继承类）
5. 接口可以实现多继承
6. 接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。
7. 接口可以继承接口，用extends

### 1.3.5 HashMap 与 HashTable的区别
1. 继承的父类不同：HashTable继承Dictory类，HashMap继承AbstractMap.但都实现了Map接口；
2. 线程安全性不同：HashTable是线程安全的,适用于多线程；HashMap是非线程安全，更适合于单线程；
3. 是否提供contains方法：HashTable中保留了contains方法，与constainsValue功能相同；HashMap中去掉了contains方法；
4. key和value是否可为null值：HashTable的key、value都不允许null值；HashMap，null可以作为key；
5. 遍历方式的内部实现不同：HashTable、HashMap都使用了Iterator，HashTable还使用过Enumeration方式；
6. hash值不同：HashTable直接使用对象的hashCode，而HashMap重新计算hash值。
7. 内部使用的数组初始化和扩容方式不同：Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂；Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。